/**
 * Meeting Transcription Process
 *
 * State machine for live meeting transcription + LLM summarization.
 *
 * Intelligence layers:
 *   overviewItems → additive log, one bullet per significant moment, never deleted mid-meeting
 *   topic         → current major theme, full rewrite when discussion shifts
 *   now           → latest exchange, always updated
 *   actionItems   → tracked list of commitments/tasks extracted from conversation
 *   participants  → names inferred from conversation
 *   talkTime      → accumulated mic vs system audio duration (tracked in Widget)
 *   sentiment     → neutral / positive / tense / negative
 *
 * Overview delta approach:
 *   LLM outputs overallDelta: string | null — appended only when genuinely new/significant.
 *   Never rewrites old items. Compaction deferred to end-of-meeting if needed.
 *
 * Token budget (approximate input):
 *   overview (12 items × 120 chars)   =  1 440
 *   topic 400 + now 200               =    600
 *   action items (10 × 120)           =  1 200
 *   history (8 × 400)                 =  3 200
 *   new content                       =    600
 *   overhead                          =    400
 *   ──────────────────────────────────────────
 *   total                     ~7 440 chars ≈ ~1 860 tokens input
 */

import { z } from 'zod';
import { callLLM } from '../../../program/llmClient';
import { parseLLMJSON } from '../../../program/utils/jsonUtils';
import { profileStorage } from '../../../lib/profileStorage';

// ============================================================================
// Constants
// ============================================================================

const STORAGE_KEY = 'meeting-transcription';
const ARCHIVE_STORAGE_KEY = 'meeting-transcription:archive';
export const SETTINGS_STORAGE_KEY = 'meeting-transcription:settings';

/** Min chars accumulated since last LLM call before we bother calling again */
export const MIN_ACCUMULATED_CHARS = 80;

/** After this ms of silence, fire LLM even if accumulated text is short */
export const STALE_TEXT_TIMEOUT_MS = 20_000;

const LLM_THROTTLE_MS = 8_000;
const MAX_HISTORY = 20;
const MAX_ARCHIVE = 10;
const LLM_HISTORY_WINDOW = 8;
const MAX_OVERVIEW_ITEMS_IN_PROMPT = 12;
const MAX_ACTION_ITEMS = 20;

/** Gap in ms after which a new recording-started is treated as a new meeting */
export const NEW_MEETING_GAP_MS = 3 * 60 * 1000;

// LLM input caps
const MAX_OVERVIEW_ITEM_CHARS = 120;
const MAX_TOPIC_CHARS         = 400;
const MAX_NOW_CHARS           = 200;
const MAX_ACTION_ITEM_CHARS   = 120;
const MAX_HISTORY_SEGMENT_CHARS = 400;
const MAX_ACCUMULATED_TEXT_CHARS = 600;

// ============================================================================
// Types
// ============================================================================

export interface SummaryLevel {
  text: string;
  /** Iconify icon name generated by LLM, e.g. "mdi:target" */
  icon: string;
  updatedAt: number;
}

export interface SummaryTree {
  /** Mirrors the latest overviewItem text — kept for archive/display compat */
  overall: SummaryLevel;
  /** Current major topic / phase. Full rewrite when discussion shifts. */
  topic: SummaryLevel;
  /** Latest exchange right now. Always updated. */
  now: SummaryLevel;
}

/** One bullet in the additive overview log. Appended, never deleted mid-meeting. */
export interface OverviewItem {
  text: string;
  ts: number;
}

export interface ActionItem {
  id: string;
  text: string;
  /** Inferred owner — participant name, "you", or undefined if unknown */
  owner?: string;
  /** Inferred deadline if mentioned, e.g. "by Friday" */
  deadline?: string;
  ts: number;
  done: boolean;
}

/** 'tense' = rising conflict/disagreement; 'negative' = clear frustration/anger */
export type SentimentLevel = 'neutral' | 'positive' | 'tense' | 'negative';

export interface Participant {
  name: string;
  audioType: 'mic' | 'system';
  firstSeenAt: number;
}

export interface TalkTime {
  micMs: number;
  systemMs: number;
}

export interface FeedEntry {
  id: string;
  text: string;
  audioType: 'mic' | 'system';
  ts: number;
}

export interface HistorySegment {
  text: string;
  audioType: 'mic' | 'system';
  ts: number;
}

export interface MeetingSettings {
  userName: string;
  meetingContext: string;
}

export interface MeetingState {
  displayFeed: FeedEntry[];
  history: HistorySegment[];
  summaryTree: SummaryTree;
  overviewItems: OverviewItem[];
  actionItems: ActionItem[];
  participants: Participant[];
  talkTime: TalkTime;
  sentiment: SentimentLevel;
  lastLLMCallAt: number;
  lastUpdatedAt: number;
  llmDurationMs: number;
  segmentCount: number;
  startedAt: number;
  /** Auto-generated meeting title (produced by end-of-meeting LLM call) */
  title: string;
}

export interface ArchivedMeeting {
  id: string;
  startedAt: number;
  endedAt: number;
  summaryTree: SummaryTree;
  overviewItems: OverviewItem[];
  actionItems: ActionItem[];
  participants: Participant[];
  talkTime: TalkTime;
  displayFeed: FeedEntry[];
  history: HistorySegment[];
  segmentCount: number;
  /** Auto-generated meeting title (produced by end-of-meeting LLM call) */
  title: string;
}

export interface MeetingUpdateResult {
  state: MeetingState;
  llmRan: boolean;
}

// ============================================================================
// Zod schemas
// ============================================================================

const SummaryLevelSchema = z.object({
  text: z.string(),
  icon: z.string(),
  updatedAt: z.number(),
});

const SummaryTreeSchema = z.object({
  overall: SummaryLevelSchema,
  topic: SummaryLevelSchema,
  now: SummaryLevelSchema,
});

const FeedEntrySchema = z.object({
  id: z.string(),
  text: z.string(),
  audioType: z.enum(['mic', 'system']),
  ts: z.number(),
});

const HistorySegmentSchema = z.object({
  text: z.string(),
  audioType: z.enum(['mic', 'system']),
  ts: z.number(),
});

const OverviewItemSchema = z.object({
  text: z.string(),
  ts: z.number(),
});

const ActionItemSchema = z.object({
  id: z.string(),
  text: z.string(),
  owner: z.string().optional(),
  deadline: z.string().optional(),
  ts: z.number(),
  done: z.boolean(),
});

const ParticipantSchema = z.object({
  name: z.string(),
  audioType: z.enum(['mic', 'system']),
  firstSeenAt: z.number(),
});

const TalkTimeSchema = z.object({
  micMs: z.number(),
  systemMs: z.number(),
});

const SentimentLevelSchema = z.enum(['neutral', 'positive', 'tense', 'negative']);

const MeetingStateSchema = z.object({
  displayFeed: z.array(FeedEntrySchema),
  history: z.array(HistorySegmentSchema),
  summaryTree: SummaryTreeSchema,
  overviewItems: z.array(OverviewItemSchema),
  actionItems: z.array(ActionItemSchema),
  participants: z.array(ParticipantSchema),
  talkTime: TalkTimeSchema,
  sentiment: SentimentLevelSchema,
  lastLLMCallAt: z.number(),
  lastUpdatedAt: z.number(),
  llmDurationMs: z.number(),
  segmentCount: z.number(),
  startedAt: z.number(),
  // default('') so existing stored data without this field migrates instead of being wiped
  title: z.string().default(''),
});

const ArchivedMeetingSchema = z.object({
  id: z.string(),
  startedAt: z.number(),
  endedAt: z.number(),
  summaryTree: SummaryTreeSchema,
  overviewItems: z.array(OverviewItemSchema),
  actionItems: z.array(ActionItemSchema),
  participants: z.array(ParticipantSchema),
  talkTime: TalkTimeSchema,
  displayFeed: z.array(FeedEntrySchema),
  history: z.array(HistorySegmentSchema),
  segmentCount: z.number(),
  // default('') so existing archived meetings without this field migrate instead of being wiped
  title: z.string().default(''),
});

const MeetingSettingsSchema = z.object({
  userName: z.string(),
  meetingContext: z.string(),
});

// ============================================================================
// Storage
// ============================================================================

export function saveMeetingState(state: MeetingState): void {
  try {
    profileStorage.setJSON(STORAGE_KEY, state);
  } catch (error) {
    console.warn('[MeetingTranscription] Failed to save state:', error);
  }
}

export function loadMeetingState(): MeetingState | null {
  try {
    const raw = profileStorage.getJSON<unknown>(STORAGE_KEY);
    if (raw == null) return null;
    const result = MeetingStateSchema.safeParse(raw);
    if (!result.success) {
      console.warn('[MeetingTranscription] State schema changed — resetting:', result.error.issues);
      return null;
    }
    return result.data;
  } catch (error) {
    console.warn('[MeetingTranscription] Failed to load state:', error);
    return null;
  }
}

export function clearMeetingState(): void {
  try {
    profileStorage.removeItem(STORAGE_KEY);
  } catch { /* ignore */ }
}

export function loadArchivedMeetings(): ArchivedMeeting[] {
  try {
    const raw = profileStorage.getJSON<unknown>(ARCHIVE_STORAGE_KEY);
    if (raw == null) return [];
    const result = z.array(ArchivedMeetingSchema).safeParse(raw);
    if (!result.success) {
      console.warn('[MeetingTranscription] Archive schema changed — clearing:', result.error.issues);
      return [];
    }
    return result.data;
  } catch {
    return [];
  }
}

function saveArchivedMeetings(meetings: ArchivedMeeting[]): void {
  try {
    profileStorage.setJSON(ARCHIVE_STORAGE_KEY, meetings);
  } catch (error) {
    console.warn('[MeetingTranscription] Failed to save archive:', error);
  }
}

export function archiveCurrentMeeting(state: MeetingState): ArchivedMeeting[] {
  if (state.segmentCount === 0) return loadArchivedMeetings();

  const archived: ArchivedMeeting = {
    id: `meeting-${state.startedAt}`,
    startedAt: state.startedAt,
    endedAt: Date.now(),
    summaryTree: state.summaryTree,
    overviewItems: state.overviewItems,
    actionItems: state.actionItems,
    participants: state.participants,
    talkTime: state.talkTime,
    displayFeed: state.displayFeed,
    history: state.history,
    segmentCount: state.segmentCount,
    title: state.title,
  };

  const existing = loadArchivedMeetings();
  const deduplicated = existing.filter((m) => m.id !== archived.id);
  const updated = [archived, ...deduplicated].slice(0, MAX_ARCHIVE);
  saveArchivedMeetings(updated);
  return updated;
}

/**
 * Patches the title of an already-archived meeting by id.
 * Called after the end-of-meeting LLM call succeeds — the archive was already
 * saved before the LLM ran, so this just fills in the title retroactively.
 */
export function updateArchivedMeetingTitle(meetingId: string, title: string): ArchivedMeeting[] {
  const existing = loadArchivedMeetings();
  const updated = existing.map((m) => (m.id === meetingId ? { ...m, title } : m));
  saveArchivedMeetings(updated);
  return updated;
}

export function loadMeetingSettings(): MeetingSettings {
  try {
    const raw = profileStorage.getJSON<unknown>(SETTINGS_STORAGE_KEY);
    if (raw == null) return { userName: '', meetingContext: '' };
    const result = MeetingSettingsSchema.safeParse(raw);
    return result.success ? result.data : { userName: '', meetingContext: '' };
  } catch {
    return { userName: '', meetingContext: '' };
  }
}

export function saveMeetingSettings(settings: MeetingSettings): void {
  try {
    profileStorage.setJSON(SETTINGS_STORAGE_KEY, settings);
  } catch (error) {
    console.warn('[MeetingTranscription] Failed to save settings:', error);
  }
}

// ============================================================================
// Initial state
// ============================================================================

export function createInitialMeetingState(): MeetingState {
  return {
    displayFeed: [],
    history: [],
    summaryTree: {
      overall: { text: '', icon: 'mdi:flag-outline', updatedAt: 0 },
      topic:   { text: '', icon: 'mdi:comment-multiple-outline', updatedAt: 0 },
      now:     { text: '', icon: 'mdi:lightning-bolt-outline', updatedAt: 0 },
    },
    overviewItems: [],
    actionItems: [],
    participants: [],
    talkTime: { micMs: 0, systemMs: 0 },
    sentiment: 'neutral',
    lastLLMCallAt: 0,
    lastUpdatedAt: Date.now(),
    llmDurationMs: 0,
    segmentCount: 0,
    startedAt: Date.now(),
    title: '',
  };
}

// ============================================================================
// LLM Prompts
// ============================================================================

function buildSystemPrompt(settings: MeetingSettings): string {
  const micLabel = settings.userName ? `you (${settings.userName})` : 'you (the local user)';
  const contextLine = settings.meetingContext
    ? `\nMEETING CONTEXT: ${settings.meetingContext}`
    : '';

  return `You are a live meeting intelligence assistant.${contextLine}

━━━ INPUT SOURCE ━━━
Input is raw speech-to-text transcription — it may contain recognition errors or mispronunciations.
Use surrounding context to infer intended meaning. Do not autocorrect unless highly confident.

━━━ AUDIO CHANNELS ━━━
• "mic"    = ${micLabel}
• "system" = remote participants — one or more people, audio routed through Teams / Zoom / Meet / etc.
             If a name is clearly audible (e.g. "Hi, I'm Sarah"), note them as a participant.

ECHO / BLEED WARNING:
Without headphones, system audio plays through speakers and is picked up by the mic — so the same
speech may appear as both "system" and "mic" in close succession. If a "mic" segment is nearly
identical in content to a recent "system" segment, treat it as echo/bleed — do NOT attribute it
to the local user.

━━━ VOICE STYLE ━━━
Compact, never paraphrase into 3rd-person narrative.
✗ WRONG: "The team discussed budget concerns"
✓ RIGHT:  "Budget tight — can't fund both projects this quarter"
Preserve first-person voice: keep "I think", "We need", "Let's" intact.

━━━ OVERVIEW (additive bullet log) ━━━
The overview is an immutable log of the whole meeting — bullets are NEVER rewritten or removed.
• Output overallDelta ONLY when the new content contains something genuinely significant:
  a new decision, commitment, goal, key fact, or clear topic shift.
• If it is continuation, small-talk, repetition, or elaboration of an existing bullet — output null.
• One short phrase, max 15 words. First-person voice.
• You are APPENDING a new bullet, not rewriting anything.

━━━ TOPIC ━━━
Current major theme. Fully rewrite when discussion clearly shifts. Max 50 words.

━━━ NOW ━━━
Most recent exchange — what is being said right now. Always update. Max 30 words.

━━━ ACTION ITEMS ━━━
Extract explicit or strongly implied tasks/commitments from the NEW content only.
Return only NEW items — do not re-list existing ones. Empty array if none.

Only extract items that are clearly assignable, concrete, and would stand alone in formal meeting notes. Skip vague fragments and rhetorical statements.

Before adding a new item, check the OPEN ACTION ITEMS list: if the new item substantially duplicates
an existing open item (same task, even if phrased differently), skip it — do not add a duplicate.
Each: short text, optional owner ("you" for mic-user, participant name, or omit), optional deadline.

━━━ SENTIMENT ━━━
Overall mood right now:
  "neutral"  = ordinary discussion
  "positive" = enthusiasm, agreement, good energy
  "tense"    = disagreement, friction, raised stakes
  "negative" = clear frustration or conflict

━━━ PARTICIPANTS ━━━
If a name is clearly introduced in the new content, return them. Empty array otherwise.

━━━ RESPONSE FORMAT (strict JSON, no markdown) ━━━
{
  "overallDelta": "short phrase" | null,
  "overallIcon": "mdi:... (only when overallDelta is non-null)",
  "topic":  { "text": "...", "icon": "mdi:..." },
  "now":    { "text": "...", "icon": "mdi:..." },
  "actionItems": [{ "text": "...", "owner": "..." | null, "deadline": "..." | null }],
  "sentiment": "neutral" | "positive" | "tense" | "negative",
  "newParticipants": [{ "name": "...", "audioType": "mic" | "system" }]
}`;
}

function truncate(text: string, max: number): string {
  if (text.length <= max) return text;
  return text.slice(0, max) + '…';
}

function buildUserPrompt(
  state: MeetingState,
  accumulatedText: string,
  latestAudioType: 'mic' | 'system'
): string {
  const { summaryTree: tree } = state;

  const overviewBlock = state.overviewItems.length === 0
    ? '(meeting just started — no overview items yet)'
    : state.overviewItems
        .slice(-MAX_OVERVIEW_ITEMS_IN_PROMPT)
        .map((item, i) => `${i + 1}. ${truncate(item.text, MAX_OVERVIEW_ITEM_CHARS)}`)
        .join('\n');

  const topicText = tree.topic.text ? truncate(tree.topic.text, MAX_TOPIC_CHARS) : '(none yet)';
  const nowText   = tree.now.text   ? truncate(tree.now.text,   MAX_NOW_CHARS)   : '(nothing yet)';

  const openActions = state.actionItems.filter((a) => !a.done);
  const actionItemsBlock = openActions.length === 0
    ? '(none)'
    : openActions
        .slice(-10)
        .map((a) => {
          let line = `• ${truncate(a.text, MAX_ACTION_ITEM_CHARS)}`;
          if (a.owner) line += ` [${a.owner}]`;
          if (a.deadline) line += ` — ${a.deadline}`;
          return line;
        })
        .join('\n');

  const recentHistory = state.history
    .slice(-LLM_HISTORY_WINDOW)
    .map((s) => `[${s.audioType === 'mic' ? 'MIC' : 'SYSTEM'}] ${truncate(s.text, MAX_HISTORY_SEGMENT_CHARS)}`)
    .join('\n');

  const participantsLine = state.participants.length > 0
    ? `KNOWN PARTICIPANTS: ${state.participants.map((p) => `${p.name} (${p.audioType})`).join(', ')}\n\n`
    : '';

  // Appended last so the stable prefix above remains cacheable by the LLM API.
  const sessionTime = new Date().toISOString().slice(0, 16).replace('T', ' ') + ' UTC';

  return `CURRENT OVERVIEW LOG:
${overviewBlock}

CURRENT TOPIC: ${topicText}
CURRENT NOW:   ${nowText}

OPEN ACTION ITEMS:
${actionItemsBlock}

${participantsLine}RECENT HISTORY:
${recentHistory || '(none yet)'}

NEW CONTENT [source: ${latestAudioType === 'mic' ? 'MIC' : 'SYSTEM'}]:
${truncate(accumulatedText, MAX_ACCUMULATED_TEXT_CHARS)}

<meta>current_time: ${sessionTime}</meta>`;
}

// ============================================================================
// State machine update
// ============================================================================

/**
 * Run an LLM update cycle with the text accumulated since the last call.
 *
 * Widget owns: displayFeed, segmentCount, talkTime, accumulation logic.
 * This function owns: summaryTree, overviewItems, actionItems, participants,
 *                     sentiment, history, lastLLMCallAt, llmDurationMs, storage.
 */
export async function processMeetingUpdate(
  state: MeetingState,
  accumulatedText: string,
  latestAudioType: 'mic' | 'system',
  settings: MeetingSettings,
  forceImmediate = false
): Promise<MeetingUpdateResult> {
  const now = Date.now();
  const timeSinceLast = now - state.lastLLMCallAt;

  if (!forceImmediate && timeSinceLast < LLM_THROTTLE_MS) {
    return { state, llmRan: false };
  }

  const startTime = performance.now();
  try {
    const response = await callLLM({
      tier: 'medium',
      prompt: buildUserPrompt(state, accumulatedText, latestAudioType),
      systemPrompt: buildSystemPrompt(settings),
      options: { max_tokens: 900 },
    });

    const llmDurationMs = Math.round(performance.now() - startTime);
    const { data } = parseLLMJSON(response.content);

    let newOverviewItems = [...state.overviewItems];
    const newTree: SummaryTree = {
      overall: { ...state.summaryTree.overall },
      topic:   { ...state.summaryTree.topic },
      now:     { ...state.summaryTree.now },
    };
    let newActionItems = [...state.actionItems];
    let newParticipants = [...state.participants];
    let newSentiment: SentimentLevel = state.sentiment;

    if (data && typeof data === 'object') {
      const obj = data as Record<string, unknown>;

      // ── Overview: append delta only ──
      if (typeof obj.overallDelta === 'string' && obj.overallDelta.trim()) {
        const delta = obj.overallDelta.trim();
        newOverviewItems = [...newOverviewItems, { text: delta, ts: now }];
        const icon =
          typeof obj.overallIcon === 'string' && obj.overallIcon.includes(':')
            ? (obj.overallIcon as string)
            : newTree.overall.icon;
        newTree.overall = { text: delta, icon, updatedAt: now };
      }

      // ── Topic + Now: full rewrite ──
      for (const level of ['topic', 'now'] as const) {
        const raw = obj[level];
        if (raw && typeof raw === 'object') {
          const l = raw as Record<string, unknown>;
          if (typeof l.text === 'string' && l.text.trim()) {
            newTree[level] = {
              text: l.text.trim(),
              icon: typeof l.icon === 'string' && l.icon.includes(':') ? l.icon : newTree[level].icon,
              updatedAt: now,
            };
          }
        }
      }

      // ── Action items: append new ones ──
      const rawItems = obj.actionItems;
      if (Array.isArray(rawItems)) {
        for (const raw of rawItems) {
          if (raw && typeof raw === 'object') {
            const item = raw as Record<string, unknown>;
            if (typeof item.text === 'string' && item.text.trim()) {
              newActionItems = [
                ...newActionItems,
                {
                  id: `ai-${now}-${Math.random().toString(36).slice(2, 7)}`,
                  text: item.text.trim(),
                  owner: typeof item.owner === 'string' && item.owner.trim() ? item.owner.trim() : undefined,
                  deadline: typeof item.deadline === 'string' && item.deadline.trim() ? item.deadline.trim() : undefined,
                  ts: now,
                  done: false,
                },
              ];
            }
          }
        }
        if (newActionItems.length > MAX_ACTION_ITEMS) {
          newActionItems = newActionItems.slice(-MAX_ACTION_ITEMS);
        }
      }

      // ── Sentiment ──
      const s = obj.sentiment;
      if (s === 'neutral' || s === 'positive' || s === 'tense' || s === 'negative') {
        newSentiment = s;
      }

      // ── New participants: merge, no duplicates ──
      const rawParticipants = obj.newParticipants;
      if (Array.isArray(rawParticipants)) {
        for (const raw of rawParticipants) {
          if (raw && typeof raw === 'object') {
            const p = raw as Record<string, unknown>;
            if (typeof p.name === 'string' && p.name.trim()) {
              const name = p.name.trim();
              const audioType: 'mic' | 'system' = p.audioType === 'mic' ? 'mic' : 'system';
              if (!newParticipants.some((e) => e.name.toLowerCase() === name.toLowerCase())) {
                newParticipants = [...newParticipants, { name, audioType, firstSeenAt: now }];
              }
            }
          }
        }
      }
    }

    // ── History ──
    const historyEntry: HistorySegment = {
      text: truncate(accumulatedText, MAX_HISTORY_SEGMENT_CHARS),
      audioType: latestAudioType,
      ts: now,
    };
    const updatedHistory = [...state.history, historyEntry];
    if (updatedHistory.length > MAX_HISTORY) {
      updatedHistory.splice(0, updatedHistory.length - MAX_HISTORY);
    }

    const newState: MeetingState = {
      ...state,
      history: updatedHistory,
      summaryTree: newTree,
      overviewItems: newOverviewItems,
      actionItems: newActionItems,
      participants: newParticipants,
      sentiment: newSentiment,
      lastLLMCallAt: now,
      llmDurationMs,
    };

    saveMeetingState(newState);
    return { state: newState, llmRan: true };
  } catch (error) {
    console.error('[MeetingTranscription] LLM call failed:', error);
    return { state: { ...state, lastLLMCallAt: now }, llmRan: false };
  }
}

// ============================================================================
// End-of-meeting summary
//
// Single LLM call fired once when recording ends (after the final flush).
// This is the designated slot for ALL future end-of-meeting features.
// Currently generates: title.
// Future: decisions log, key numbers, follow-up email draft, etc.
// ============================================================================

/**
 * Generates a concise meeting title from the accumulated overview + topic.
 * Uses the `small` tier for speed — fires once after recording ends.
 * Returns the updated state (with title set) and persists it.
 */
export async function generateMeetingEndSummary(
  state: MeetingState,
  settings: MeetingSettings
): Promise<MeetingState> {
  if (state.segmentCount === 0) return state;

  const overviewText = state.overviewItems.map((item, i) => `${i + 1}. ${item.text}`).join('\n');
  const topicText = state.summaryTree.topic.text || '';
  const contextLine = settings.meetingContext ? `\nMeeting context: ${settings.meetingContext}` : '';

  const systemPrompt = `You generate concise meeting titles from summaries. Reply with strict JSON only, no markdown.`;
  const userPrompt = `Generate a short meeting title (5–9 words max) that captures the main purpose or outcome.${contextLine}

Overview log:
${overviewText || '(no overview)'}

Final topic: ${topicText || '(none)'}

Reply format: { "title": "..." }`;

  try {
    const response = await callLLM({
      tier: 'small',
      prompt: userPrompt,
      systemPrompt,
      options: { max_tokens: 80 },
    });

    const { data } = parseLLMJSON(response.content);
    const title =
      data && typeof data === 'object' && typeof (data as Record<string, unknown>).title === 'string'
        ? ((data as Record<string, unknown>).title as string).trim()
        : '';

    if (!title) return state;

    const newState: MeetingState = { ...state, title };
    saveMeetingState(newState);
    return newState;
  } catch (error) {
    console.error('[MeetingTranscription] End-of-meeting summary failed:', error);
    return state;
  }
}
